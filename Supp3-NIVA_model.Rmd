---
title: "Supplementary 3 - SELM test on data from the 1000 lakes survey 2019"
author: "Camille Crapart"
date: "4 4 2022"
output: 
  bookdown::html_document2:
    toc: true
    toc_float: true
    number_sections: true
    code_folding: hide 
bibliography: C:\\Users\\raine\\Documents\\UiO\\Bibtex\\Finstad.bib
link-citations: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, collapse = T, message = F, warning = F, error = F, fig.align = "center")
```

```{r libraries}
library(readxl)
library(ggplot2)
library(sf)
```

# 1000-lakes survey dataset

The data from the 1000-lakes survey in 2019 was provided by NIVA and is available on GitHub.   

## NIVA data

All the catchment data (from ???) and the chemistry data (from the survey conducted by NIVA in 2019, @NIVA2020) were included in the dataset provided by NIVA. The catchment polygons as well as the sampling points were also calculated and provided by NIVA. The only parameter missing was the NDVI, which was subsequently extracted based on the catchment polygons.

```{r load-geometry, eval = F}
lake.poly <- st_read("C:/Users/raine/Documents/UiO/Paper_3/catchments_poly/lakes1000cat.shp")
lake.point <- st_read("C:/Users/raine/Documents/UiO/Paper_3/catchments_poly/lakes1000stations.shp")
```

```{r load-niva-dataset}
niva <- read_xlsx("niva_selection.xlsx")
ggplot(niva)+geom_point(aes(x = longitude, y = latitude, col = toc_2019))+
  scale_color_distiller(type = "seq", palette = 8, direction = -1)
```

## NDVI 

The NDVI was extracted for the year 2015 from the GIMMS dataset, as data from this database was not available for later dates. Other databases like Copernicus could have provided this data, but GIMMS was used for the original model and we assumed that the changes in mean NDVI are minimal in 3 years (as NDVI is taken for y-1). For details about the extraction of NDVI on the catchment, see Supplementary 1.

```{r download-NDVI-raster-2015, eval = F}
# http://poles.tpdc.ac.cn/en/data/9775f2b4-7370-4e5e-a537-3482c9a83d88/

ndvi.2015 <- downloadGimms(x= 2015,y=2015,dsn = "NDVI")
 
ndvi.max.2015 <- monthlyComposite(ndvi.2015,monthlyIndices(ndvi.2015))
saveRDS(ndvi.max.2015,"ndvi.max.2015.rds")
```

```{r NDVI, eval = F}
ndvi.max.2015 <- readRDS("ndvi.max.2015.rds")

# Makes the raster smaller, ensuring faster processing of the data
summer.scandinavia.2015 <- raster::crop(ndvi.max.2015,c(0,35,55,73))


summer.scan <- reclassify(summer.scandinavia.2015, cbind(-Inf, 0, NA), right=FALSE)

summer.mean.2015 <- raster::stack(summer.scan[[6]],summer.scan[[7]],summer.scan[[8]]) %>% mean()

summer.ndvi.2015 <- raster::extract(summer.mean.2015,lake.poly, fun = mean, df = T, sp = T, na.rm = T)
names(summer.ndvi.2015) <- c("station_id","ndvi")
summer.ndvi.2015$NDVI <- floor(summer.ndvi.2015$ndvi/10)/1000

saveRDS(summer.ndvi.2015, "NIVA_test/100lakes.summer.ndvi.2015.rds")
write.csv(summer.ndvi.2015,"NIVA_test/100lakes.summer.ndvi.2015.csv")
```

## Gather dataset

The dataset from NIVA and the NDVI values were merged and the variables were given names matching the Fennoscandian dataset. The projection of the polygons was converted to the projection used in the present project (EU33).

```{r niva-merged, eval = F}

summer.ndvi.2015 <- readRDS("NIVA_test/100lakes.summer.ndvi.2015.rds")
niva.ndvi <- sp::merge(summer.ndvi.2015, select(st_drop_geometry(lake.point), c("statn_d", "sttn_cd", "longitd", "latitud")), by.x = "station_id", by.y = "statn_d")

niva_data <- niva.ndvi %>% merge(select(niva, c("station_id","station_code", "agriculture","forest","peat","nilu_ndep_2012_2016","nilu_sdep_2012_2016", "rr_2m_19", "toc_2019")), by.y = "station_code", by.x = "sttn_cd")
niva_data$Runoff <- niva_data$rr_2m_19 %>% as.numeric()
niva_data$logRunoff <- log(niva_data$Runoff)
niva_data$Bog <- niva_data$peat/100
niva_data$Forest <- niva_data$forest/100
niva_data$Arable <- niva_data$agriculture/100
niva_data$TNdep <- niva_data$nilu_ndep_2012_2016 * 10
niva_data$TSdep <- niva_data$nilu_sdep_2012_2016 * 100

saveRDS(niva_data,"NIVA_test/niva_data.rds")
niva_data <- readRDS("NIVA_test/niva_data.rds")

niva_final <- niva_data[-which(is.na(niva_data$Bog) == T),] 
niva_final <- niva_final[-which(is.na(niva_final$logRunoff) == T),]
niva_final <- niva_final[-which(is.na(niva_final$NDVI) == T), ]
#niva_final <- niva_final[-which(is.na(niva_final$Forest) == T), ]
#niva_final <- niva_final[-which(is.na(niva_final$Arable) == T), ]
niva_final <- niva_final[-which(is.na(niva_final$TNdep) == T), ]
# niva_final <- niva_final[-which(is.na(niva_final$TSdep) == T), ]

wr.sf.95 <- readRDS("WR/wr.sf.95.rds")
niva_final <- st_as_sf(niva_final) %>% st_transform(crs(wr.sf.95))
 
saveRDS(niva_final, "NIVA_test/niva_final.rds")
```
```{r plot-toc-niva}
niva_final <- readRDS("NIVA_test/niva_final.rds")
ggplot(st_as_sf(niva_final))+geom_sf(aes(fill = toc_2019, col = toc_2019))+
  scale_color_distiller(palette = 8, aesthetics = c("fill","col"))
```

# Model

In order to predict the TOC in 2019 using the SELM, a neighbour matrix with the NIVA-lakes is first computed. 
```{r niva-kmat, eval = F}
niva_final <- readRDS("NIVA_test/niva_final.rds")
niva.kmat <- st_centroid(niva_final, of_largest_polygon = T) %>% knearneigh(k = 100) %>% knn2nb() %>% nb2listw()
saveRDS(niva.kmat,"NIVA_test/niva.kmat.rds")
```

The SELM is then applied to the 2019-dataset.

```{r predict-toc, eval = F}
sem.model <- readRDS("sem.fen.simple.Rdata")
niva_final <- readRDS("NIVA_test/niva_final.rds")
niva.kmat <- readRDS("NIVA_test/niva.kmat.rds")

fm <- logTOC~NDVI+logRunoff+Bog

niva_fit <- predict(sem.model, newdata = niva_final, niva.kmat)

niva_predict <- cbind(niva_final, niva_fit)
niva_predict$diffTOC <- exp(niva_predict$fit) - niva_predict$toc_2019

niva_predict$diffLogTOC <- log(niva_predict$toc_2019) - niva_predict$fit


saveRDS(niva_predict,"NIVA_test/niva_predict.rds")
```

```{r plot-model-results}
niva_predict <- readRDS("NIVA_test/niva_predict.rds")

ggplot(niva_predict) + geom_point(aes(x = log(toc_2019), y = fit))+
  labs(x = "log(TOC 2019)", y = "Predicted log(TOC)")+
  annotate(geom = "label", label = paste("r = ", round(cor(log(niva_predict$toc_2019),niva_predict$fit),2)), x = 2, y = 0)+
  theme_minimal()

```
```{r maps-toc-predictions, eval=F}
wr.sf.95 <- readRDS("WR/wr.sf.95.rds")
niva_predict <- readRDS("NIVA_test/niva_predict.rds")

nor <- st_read("Country_shapefile/norway.shp") %>% st_transform(st_crs(wr.sf.95))
mypal <- brewer.pal(9, name = "RdYlGn")
lims.toc <- c(min(c(niva_predict$toc_2019, exp(niva_predict$fit))), max((c(niva_predict$toc_2019, exp(niva_predict$fit)))))
  
diff.niva <- ggplot() +   geom_sf(data = nor, fill = "lightgray", col = "lightgray")+
  geom_sf(data = niva_predict, aes(fill = diffTOC, col = diffTOC)) + 
  scale_color_gradient2(low = mypal[9],high = mypal[1], mid = mypal[5], midpoint = 0, name = "Difference between\nobserved and predicted TOC\nwith NDVI, bogs, runoff (mg/L)", aesthetics = c("fill","col"))+
  labs(x = "", y = "")+
  theme_minimal(base_size = 6)+
  theme(legend.position = "bottom")
ggsave(plot = diff.niva, filename = "NIVA_test/diff.niva.png", dpi = "retina", width = 8, height = 10, units = "cm")
  
fitted.niva <- ggplot() +  geom_sf(data = nor, fill = "lightgray", col = "lightgray")+
  geom_sf(data = niva_predict, aes(fill = exp(fit), col = exp(fit))) + 
  scale_color_distiller(type = "seq", palette = 8, aesthetics = c("fill","col"), direction = 1, name = "Fitted TOC (mg/L)", limits = lims.toc)+
  labs(x = "", y = "")+
  theme_minimal(base_size = 6)+
  theme(legend.position = "bottom")

ggsave(plot = fitted.niva, filename =  "NIVA_test/fitted_niva.png",dpi = "retina", width = 8, height = 10, units = "cm")

obs.niva <- ggplot() + geom_sf(data = nor, fill = "lightgray", col = "lightgray") +
  geom_sf(data = niva_predict, aes(fill = toc_2019, col = toc_2019)) + 
  scale_color_distiller(type = "seq", palette = 8, aesthetics = c("fill","col"), direction = 1, name = "Sampled TOC (mg/L)", limits = lims.toc)+
  labs(x = "", y = "")+
  theme_minimal(base_size = 6)+
  theme(legend.position = "bottom")

ggsave(plot = obs.niva, filename = "NIVA_test/obs_niva.png",dpi = "retina", width = 8, height = 10, units = "cm", device = "png")
```

```{r include-maps}
knitr::include_graphics(c("NIVA_test/obs_niva.png", "NIVA_test/fitted_niva.png", "NIVA_test/diff.niva.png"))
```

# References
