---
title: "Remote sensing and toc concentration"
author: "Camille M. Crapart"
date: "29 9 2021"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_float: true
    number_sections: true
---
# Introduction



# Methods

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T, message = F, warning = F, error = F, fig.align = "center")
```

```{r library}
library(DBI)
library(sf)
library(dplyr)
library(gimms)

library(ncdf4)
library(rgdal)

library(stringr)
library(ggplot2)
library(cowplot)
library(spdep)

source("f_plotspatial.R")
```

# Data preparation

## Data from ecco_biwa datavase

The catchment and TOC data are stored on the PostgreSQL database ecco_biwa, accessed through Rstudio using the st_read function (sf package @Pebesma2021) and the dplyr package @Wickhman2021. 
Each catchment polygon is linked to the corresponding TOC concentration via an ebint internal to the ecco_biwa database.

The catchment polygons were designed by an elevation model and are assigned to the studied lake based on the distance to the sampling coordinates.

## Data gathering and cleaning

```{r gather-data}
country <- readRDS("country.Rdata")
toc.df <- readRDS("toc.df.Rdata")

summer.ndvi <- readRDS("summer.ndvi.Rdata")
runoff.df <- readRDS("runoff.df.Rdata")

remote.set <- merge(country,toc.df, by = "ebint") %>% merge(summer.ndvi, by = "ebint") %>% merge(runoff.df,by = "ebint")

remote.set$uncertain <- ifelse(remote.set$dist_closest_ebint/remote.set$dist_2nd_closest_ebint > 0.5, FALSE, TRUE)
remote.set$uncertain[which(is.na(remote.set$uncertain)==TRUE)] <- FALSE

remote.set <- remote.set %>% filter(toc_mg_l >= 0)
remote.set <- remote.set %>% filter(uncertain == FALSE)
remote.set <- remote.set %>% filter(mean.runoff < exp(20))
remote.set <- remote.set %>% filter(ndvi.value > 0)
dim(remote.set)

remote.set$mean.runoff <- remote.set$mean.runoff * 1e6 # converts to mg/m2/s


```

# Analysis
## Histogram
```{r hist, results = F, fig.dim = c(24,8)}

h_list <- c()

for (i in c("toc_mg_l","ndvi.value","mean.runoff")){
  if(IQR(remote.set[[i]]) > 0.1){
  hi <- ggplot(data = remote.set,aes_string(i))+geom_histogram(stat = "bin",na.rm = T,binwidth = function(x) 2*IQR(x, na.rm = T)/(length(x)^(1/3)))+labs(y="",title = i)+theme_light(base_size = 20)
  }else{
    hi <- ggplot(data = remote.set,aes_string(i))+geom_histogram(stat = "bin",na.rm = T)+labs(y="",title = i)+theme_light(base_size = 20)
  }
  h_list[[i]] <- hi
}

cowplot::plot_grid(plotlist = h_list,ncol=3)
```
TOC and runoff are squewed to the right so they are log-transformed.

```{r log-transform}
remote.set$log.toc <- log10(remote.set$toc_mg_l+1e-3) %>% scale() #to avoid log tranform 0
remote.set$log.runoff <- log10(remote.set$mean.runoff+1e-3) %>% scale() #to avoid log tranform 0
remote.set$ndvi <- scale(remote.set$ndvi.value)

remote.spdf <- SpatialPointsDataFrame(remote.set[,c("longitude","latitude")],remote.set)

f_plotspatial(remote.set,var = remote.set$toc_mg_l, plottitle = "TOC (mg/L) from Northern European lake study 1995", midpoint = 20)
f_plotspatial(remote.set,var=remote.set$log.toc,plottitle="log(TOC)")
f_plotspatial(remote.set,var=remote.set$ndvi.value,plottitle="NDVI GIMMS v3, summer 1994",midpoint = 0.6)
f_plotspatial(remote.set,var=remote.set$log.runoff,plottitle="log(runoff)")
#f_plotspatial(waterchem_1995,var = waterchem_1995$ndvi_summer_lag1yr, plottitle = "NDVI waterchem")
#f_plotspatial(waterchem_1995,var = waterchem_1995$runoff, plottitle = "runoff waterchem")
f_plotspatial(remote.set,var=remote.set$mean.runoff, plottitle = "Mean runoff from CORDEX (1960-1990)",midpoint=50)

```

## Spatial autocorrelation

```{r neighbour-matrix, eval = F}
library(spdep)
k.neigh.set <- knearneigh(remote.spdf, k = 100)
k.neigh.nb.set <- knn2nb(k.neigh.set)
k.neigh.w.set <- nb2listw(k.neigh.nb.set)
saveRDS(k.neigh.w.set,"k.neigh.w.set.Rdata")
```
```{r spatial-autocorrelation, eval = T}
k.neigh.w.set <- readRDS("k.neigh.w.set.Rdata")
moran.list <- c() 
for (i in c("toc_mg_l","ndvi.value","mean.runoff", pr)){
     moran.list[[i]] <- moran.test(remote.set[,i],k.neigh.w.set, na.action = na.omit, alternative = "two.sided")
}

moran.df <- data.frame(c("toc","ndvi","runoff")) %>% setNames("parameter")
moran.df$I <- NA
moran.df$p <- NA
   
for (i in 1:length(moran.list)){
     moran.df$I[i] <- moran.list[[i]]$estimate[1]
     moran.df$p[i] <- moran.list[[i]]$p.value
   }
   
saveRDS(moran.df,"moran.df.Rdata")
```
```{r spatial-autocorrelation-plot}
moran.df <- readRDS("moran.df.Rdata")
moran.df <- moran.df %>% mutate(p_value = case_when(p < 0.001~"< 0.001",p < 0.05 ~ "< 0.05",p < 0.1 ~"< 0.1", p > 0.1 ~" > 0.1"))

moran.df$parameter <- factor(moran.df$parameter, levels = moran.df$parameter[order(moran.df$I)])

knitr::kable(moran.df, digits = 4)
g.moran <- ggplot(filter(moran.df,!parameter %in% c("longitude","latitude", "id")))+geom_col(aes(x=I,y=parameter,fill=p_value))+scale_fill_viridis_d()+theme_light()+geom_vline(xintercept = 1/(dim(remote.set)[1]-1))
plot(g.moran)

```

# OLS for Norway

```{r OLS-Norway}
norge <- remote.set %>% filter(nation == "Norway")

norge.lm <- lm(data = norge, formula = log.toc~ndvi+log.runoff)
summary(norge.lm)

norge.coef <- summary(norge.lm)$coefficients %>% as.data.frame() # %>% setNames("standardized coeficient") #%>% tibble::rownames_to_column("exp.var")

norge.spdf <- SpatialPointsDataFrame(norge[,c("longitude","latitude")],norge)

norge.kmat <- norge.spdf %>% knearneigh(k=50) %>% knn2nb %>% nb2listw
saveRDS(norge.kmat,"norge.kmat.Rdata")
norge.moran.res <- lm.morantest(norge.lm,norge.kmat,alternative = "two.sided")
moran.limit.norge <- 1/(dim(norge)[1]-1)

norge.r2 <- summary(norge.lm)$adj.r.squared

map <- f_plotspatial(data = norge, var = norge.lm$residuals,plottitle = "OLS residuals for Norway")+annotate("label",x = 8, y = 69, label = paste("Mean R2 =",round(norge.r2,2)))+annotate("label",x=8,y=68, label = paste("AIC = ", round(AIC(norge.lm),2)))+annotate("label",x=8,y=66.5,label = paste("Moran's I of \n residuals = ", round(norge.moran.res$estimate[1],3)))
plot(map)
```

```{r coef-norge-lm}
knitr::kable(norge.coef,digits = 2)
``` 

```{r spatial-autocorrelation-norway, eval = T}
norge.kmat <- readRDS("norge.kmat.Rdata")
moran.list.norge <- c() 
for (i in c("toc_mg_l","ndvi","mean.runoff")){
     moran.list.norge[[i]] <- moran.test(norge[,i],norge.kmat, na.action = na.omit, alternative = "two.sided")
}

moran.df.norge <- data.frame(c("toc","ndvi","runoff")) %>% setNames("parameter")
moran.df.norge$I <- NA
moran.df.norge$p <- NA
   
for (i in 1:length(moran.list.norge)){
     moran.df.norge$I[i] <- moran.list.norge[[i]]$estimate[1]
     moran.df.norge$p[i] <- moran.list.norge[[i]]$p.value
   }
   
saveRDS(moran.df.norge,"moran.df.norge.Rdata")
```
```{r spatial-autocorrelation-plot-norway}
moran.df.norge <- readRDS("moran.df.norge.Rdata")
moran.df.norge <- moran.df.norge %>% mutate(p_value = case_when(p < 0.001~"< 0.001",p < 0.05 ~ "< 0.05",p < 0.1 ~"< 0.1", p > 0.1 ~" > 0.1"))
moran.df.norge$p <- NULL
moran.df.norge <- rbind(moran.df.norge,c("residuals",norge.moran.res$estimate[1], "< 0.001"))
moran.df.norge$I <- as.numeric(moran.df.norge$I)

moran.df.norge$parameter <- factor(moran.df.norge$parameter, levels = moran.df.norge$parameter[order(moran.df.norge$I)])

knitr::kable(moran.df.norge, digits = 4)
g.moran.norge <- ggplot(filter(moran.df.norge,!parameter %in% c("longitude","latitude", "id")))+geom_col(aes(x=I,y=parameter,fill=p_value))+scale_fill_viridis_d()+theme_light(base_size = 20)+geom_vline(xintercept = 1/(dim(remote.set)[1]-1))
plot(g.moran.norge)

```

# Ordinary least square regression with NDVI and runoff

```{r ols, results = F}
remote.variables <- c("ndvi","log.runoff")
fm <- paste("log.toc","~",paste(remote.variables,collapse = "+")) %>% as.formula()

lm.remote <- lm(fm, data = remote.set)
summary(lm.remote)
lm.r2 <- summary(lm.remote)$adj.r.squared
moran.I.res.lm <- lm.morantest(lm.remote, k.neigh.w.set, alternative = "two.sided")
moran.test(lm.remote$residuals,k.neigh.w.set,randomisation=FALSE, alternative = "two.sided")
moran.limit.remote <- 1/(dim(remote.set)[1]-1)

map <- f_plotspatial(data = remote.set, var = lm.remote$residuals,plottitle = "OLS residuals")+annotate("label",x = 8, y = 69, label = paste("Mean R2 =",round(lm.r2,2)))+annotate("label",x=8,y=68, label = paste("AIC = ", round(AIC(lm.remote),2)))+annotate("label",x=8,y=66.5,label = paste("Moran's I of \n residuals = ", round(moran.I.res.lm$estimate[1],3)))
plot(map)

lm.coef <- lm.remote$coefficients %>% as.data.frame() %>% setNames("coef") %>% tibble::rownames_to_column("exp.var")
coef.plot <- ggplot(lm.coef[-1,])+geom_col(aes(x=exp.var,y=coef,fill=coef))+theme_light()+scale_fill_gradient2(low="#4575B4",mid="#FFFFBF",high = "#D73027",midpoint = 0)

#cowplot::plot_grid(map,coef.plot,ncol = 2)
```
```{r ols-fennoscandia-coef}
knitr::kable(summary(lm.remote)$coefficients, digits = 2)
```

# Spatially Error Model with NDVI and runoff

Lagrange multiplier test to check whether we should apply an error model or a lag model. The error model has a much higher tet stat, even if all tests are significant; therefore we apply a spatial error model. 

```{r spatial-model, eval = F}
library(spatialreg)
lagrange <- lm.LMtests(lm.remote,k.neigh.w.set,test = c("LMerr","LMlag","RLMerr","RLMlag"))

sem.remote <- errorsarlm(fm,remote.set,k.neigh.w.set)
saveRDS(sem.remote,"sem.remote.Rdata")
```
```{r results-spatial-error-model}
sem.remote <- readRDS("sem.remote.Rdata")
moran.I.res.sem <- moran.test(sem.remote$residuals, k.neigh.w.set, alternative = "two.sided")

map <- f_plotspatial(data = remote.set, var = sem.remote$residuals,plottitle = "SEM residuals")#+annotate("label",x=8,y=67, label = paste("AIC = ", round(AIC(sem.remote),2)))+annotate("label",x=8,y=68.5, label = paste(paste("Moran's I of \n residuals = ", round(moran.I.res.sem$estimate[1],4))))
plot(map)

sem.coef <- sem.remote$coefficients %>% as.data.frame() %>% setNames("coef") %>% tibble::rownames_to_column("exp.var")
coef.plot <- ggplot(sem.coef[-1,])+geom_col(aes(x=exp.var,y=coef,fill=coef))+theme_light()+scale_fill_gradient2(low="#4575B4",mid="#FFFFBF",high = "#D73027",midpoint = 0)

#cowplot::plot_grid(map,coef.plot,ncol=2)
```
```{r sem-coef}
knitr::kable(sem.coef, digits = 2)
```

# GWR 

```{r GWR-remote, eval = F}
library(GWmodel)
bw.remote <- bw.gwr(fm, data = remote.spdf, kernel = "gaussian", adaptive = T)
gwr.remote <- gwr.basic(fm, data = remote.spdf, bw = bw.remote, kernel = "gaussian", adaptive = T)

saveRDS(bw.remote, "bw.remote.Rdata")
saveRDS(gwr.remote, "gwr.remote.Rdata")

```
```{r gwss, eval = F}
gwss.remote <- gwss(data = remote.spdf, vars = c("toc_mg_l","mean.runoff","ndvi"),kernel = "gaussian", adaptive = T, bw = bw.remote)
saveRDS(gwss.remote,"gwss.remote.Rdata")

f_plotspatial(remote.set,var = gwss.remote$SDF$Corr_mean.runoff.ndvi,plottitle = "cor ndvi-runoff")
```
```{r plot-local-r2-res, fig.dim = c(24,10)}
gwr.remote <- readRDS("gwr.remote.Rdata")
plot.r2 <- f_plotspatial(remote.set,gwr.remote$SDF$Local_R2,plottitle = "Local R2")+annotate("label",x = 8, y = 69, label = paste("Mean R2 =",round(mean(gwr.remote$SDF$Local_R2),2)))+annotate("label", x = 8, y = 68, label = paste("AIC = ", round(gwr.remote$GW.diagnostic$AICc,2)))

moran.I.res.gwr <- moran.test(gwr.remote$SDF$residual, k.neigh.w.set, alternative = "two.sided")
plot.res <- f_plotspatial(remote.set, var=gwr.remote$SDF$Stud_residual,plottitle = "GWR residuals")+annotate("label",x = 9, y = 69, label = paste("Moran's I of \n residuals =", round(moran.I.res.gwr$estimate[1],4)))

cowplot::plot_grid(plot.r2,plot.res,ncol = 2)
```
```{r local-coef-moran, eval = F, results = F}
gwr.remote <- readRDS("gwr.remote.Rdata")
ndvi.moran <- moran.test(gwr.remote$SDF$ndvi, k.neigh.w.set)
runoff.moran <- moran.test(gwr.remote$SDF$log.runoff, k.neigh.w.set)
f_plotspatial(remote.set,gwr.remote$SDF$ndvi,plottitle = "Local coefficients NDVI")
mean(gwr.remote$SDF$ndvi)
f_plotspatial(remote.set,gwr.remote$SDF$log.runoff,plottitle = "Local coefficients runoff")
mean(gwr.remote$SDF$log.runoff)


```

```{r maps-train-set}
uneven <- seq(1,50,2)
even <- seq(2,50,2)
map.list <- c()
for(i in 1: length(remote.variables)){
  map <<- f_plotspatial(remote.set,remote.set[,remote.variables[i]],plottitle = remote.variables[i])+theme_void(base_size = 15)
  map.list[[even[i]]] <- map
}

```
```{r map-coef, fig.dim=c(10,8)}

for(i in 1:length(remote.variables)){
  map <<- f_plotspatial(remote.set,gwr.remote$SDF@data[,remote.variables[i]],plottitle = paste("coef",remote.variables[i]))+theme_void(base_size = 15)
  map.list[[uneven[i]]] <- map
}

cowplot::plot_grid(plotlist = map.list,ncol=2)
```
# Summary

```{r summary-performances, eval= F}
models <- c("OLS","SEM","GWR")
AIC.models <- c(AIC(lm.remote),AIC(sem.remote),gwr.remote$GW.diagnostic$AICc)
moran.res.models <- c(moran.I.res.lm$estimate[1],moran.I.res.sem$estimate[1],moran.I.res.gwr$estimate[1])


summary.table <- data.frame(models = models, AIC = AIC.models, moran.I = moran.res.models)
knitr::kable(summary.table)  
```



```{r new-set, eval = F}
new.set <- remote.set %>% dplyr::select(!c("ndvi","ndvi.value","flag.value"))
new.set <- merge(new.set,year.ndvi,by = "ebint") %>% dplyr::filter(! ndvi == "NaN")


new.spdf <- SpatialPointsDataFrame(new.set[,c("longitude","latitude")],new.set) 

new.kmat <- new.spdf %>% knearneigh(k=50) %>% knn2nb %>% nb2listw
saveRDS(new.kmat,"new.kmat.Rdata")

```

```{r sem-year, eval = F}
new.sem <- errorsarlm(fm,new.set,new.kmat)
saveRDS(sem.remote,"new.sem.Rdata")
```

```{r new-sem-results, eval = F}
new.sem <- readRDS("new.sem.Rdata")
new.kmat <- readRDS("new.kmat.Rdata")
moran.I.new.sem <- moran.test(new.sem$residuals, new.kmat, randomisation = F, alternative = "two.sided")

map <- f_plotspatial(data = new.set, var = new.sem$residuals,plottitle = "SEM residuals")#+annotate("label",x=8,y=67, label = paste("AIC = ", round(AIC(sem.remote),2)))+annotate("label",x=8,y=68.5, label = paste(paste("Moran's I of \n residuals = ", round(moran.I.res.sem$estimate[1],4))))
plot(map)

AIC(new.sem)
summary.new.sem <- new.sem %>% summary()


new.sem.coef <- summary.new.sem$Coef %>% as.data.frame() %>% tibble::rownames_to_column("exp.var") 

new.coef.plot <- ggplot(new.sem.coef[-1,])+geom_col(aes(x=exp.var,y=coef,fill=coef))+theme_light()+scale_fill_gradient2(low="#4575B4",mid="#FFFFBF",high = "#D73027",midpoint = 0)

plot(new.coef.plot)
#cowplot::plot_grid(map,coef.plot,ncol=2)
```

```{r new-sem-coef, eval = F}
knitr::kable(new.sem.coef, digits = 2)
```

```{r use-extra-data}
clc.tab.prop <- readRDS("clc.tab.prop.Rdata") %>% as.data.frame()
bogs <- clc.tab.prop[36,] %>% t() %>% as.data.frame() %>% setNames("bogs")
annual.temp <- readRDS("annual.temp.Rdata")
annual.prec <- readRDS("annual.prec.Rdata")
alt.df <- readRDS("alt.df.Rdata")
slope.fennoscandia <- readRDS("slope.fennoscandia.Rdata")
remote.2 <- merge(remote.set, bogs, by.x = "ebint", by.y = 0) %>% merge(annual.temp, by = "ebint") %>% merge(annual.prec, by = "ebint") %>% merge(slope.fennoscandia, by = "ebint") # %>% merge(alt.df, by = "ebint")
remote.2$log.bogs <- log(remote.2$bogs +0.001) %>% scale()

remote.2$temp <-  scale(remote.2$bio1/10)
remote.2$prec <- log(remote.2$bio12+0.0001) %>% scale()
remote.2$slope <- log(remote.2$layer+0.0001) %>% scale()

```

```{r sem-all-var, eval = F}
all.sem <- errorsarlm(log.toc~log.runoff+ndvi.value+log.bogs+temp+prec+slope,remote.2,k.neigh.w.set, na.action = na.omit)
saveRDS(all.sem,"all.sem.Rdata")
```

```{r all-sem-results}
all.sem <- readRDS("all.sem.Rdata")
moran.I.all.sem <- moran.test(all.sem$residuals, k.neigh.w.set, randomisation = F, alternative = "two.sided")

map <- f_plotspatial(data = remote.2, var = all.sem$residuals,plottitle = "SEM residuals")#+annotate("label",x=8,y=67, label = paste("AIC = ", round(AIC(sem.remote),2)))+annotate("label",x=8,y=68.5, label = paste(paste("Moran's I of \n residuals = ", round(moran.I.res.sem$estimate[1],4))))
plot(map)

AIC(all.sem)
summary.all.sem <- all.sem %>% summary()


all.sem.coef <- summary.all.sem$Coef %>% as.data.frame() %>% tibble::rownames_to_column("exp.var") 

all.coef.plot <- ggplot(all.sem.coef[-1,])+geom_col(aes(x=exp.var,y=Estimate,fill=Estimate))+theme_light()+scale_fill_gradient2(low="#4575B4",mid="#FFFFBF",high = "#D73027",midpoint = 0)

plot(all.coef.plot)
cor.exp.var <- remote.2 %>% dplyr::select(c("log.runoff","ndvi.value","log.bogs","temp","prec","slope")) %>% cor(use = "pairwise.complete.obs") 

corrplot::corrplot(cor.exp.var, method = "number")
#cowplot::plot_grid(map,coef.plot,ncol=2)
```

```{r all-sem-coef}
knitr::kable(all.sem.coef, digits = 2)
```

bogs, runoff, prec and slope are logged
All are scaled

```{r delogdescale-coef}
# ndvi unscaled
all.sem.coef[3,2]*sd(remote.2$log.toc)/sd(remote.2$ndvi.value)
# slope unscaled
filter(all.sem.coef,exp.var == "slope")[2]*sd(remote.2$log.toc)/sd(remote.2$ndvi.value)

```
